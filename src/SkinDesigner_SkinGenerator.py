#3D panels

# SkinDesigner: A Plugin for Building Skin Design (GPL) started by Santiago Garay

# This file is part of SkinDesigner.
# 
# Copyright (c) 2017, Santiago Garay <sgaray1970@gmail.com> 
# SkinDesigner is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published 
# by the Free Software Foundation; either version 3 of the License, 
# or (at your option) any later version. 
# 
# SkinDesigner is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with SkinDesigner; If not, see <http://www.gnu.org/licenses/>.
# 
# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>
# Skin Generator

"""
Use this component to generate a panelized design solution in the scene.
_
_
To add more panels bays in the construction, simply zoom into the component and hit the lowest "+" sign that shows up on the input side.  To remove panels from the construction, zoom into the component and hit the lowest "-" sign that shows up on the input side.
-
    Args:
        _acivate: A boolean to turn on/off the SkniGenerator solution.
        _skinSurfaceList: List of grasshopper surfaces or IDs of scene surfaces where panels will be mapped.
        Surfaces should have a Z straight linear direction in one of its domains to work.
        skinParameters: A list of optional parameter/value pairs generated by the SkinParamter component. 
        designControllers: A list of design controllers created by the Layout Controller and Panel Controller components.
        postProcFunctions:  A list of PostProcFucntion objects generated by PostProcess type components.
        panel_1: (panel_2, panel_3,....) A Panel or a list of Panel objects ( if Panel_Bay component is ised)
        to be used by the SkinGenerator solution. By adding inputs, more panel objects can be added.These input numbers (IDs) are used to reference this panel or panel bay in some design functions.
    Returns:
        postProcData: Any custom data that might be generated by the PostProcess Functions connected to SkinGenerator. 
        skinBayData: A database with panel placement infomation generated by the SkinGenerator solution.
        skinPanelData: A database with panel types generated by the SkinGenerator solution.
"""

ghenv.Component.Name = "SkinDesigner_SkinGenerator"
ghenv.Component.NickName = 'SkinGenerator'
ghenv.Component.Message = 'VER 0.5.01\nSep_23_2018'
ghenv.Component.Category = "SkinDesigner"
ghenv.Component.SubCategory = "01 | Construction"
try: ghenv.Component.AdditionalHelpFromDocStrings = "2"
except: pass

# automnatically set the right input names and types (when using + icon) 
numInputs = ghenv.Component.Params.Input.Count
accessList = ghenv.Component.Params.Input[0].Access.list
accessItem = ghenv.Component.Params.Input[0].Access.item
 
for input in range(numInputs):
    access = accessList
    if input == 0: inputName = '_activate'; access = accessItem
    elif input == 1: inputName = 'skinParameters' ; access = accessList    
    elif input == 2: inputName = '_skinSurfaceList' ; access = accessList
    elif input == 3: inputName = 'designControllers'; access = accessList   
    elif input == 4: inputName = 'postProcFunctions'; access = accessList   
    else: inputName = 'panel_' + str(input-4)

    ghenv.Component.Params.Input[input].NickName = inputName
    ghenv.Component.Params.Input[input].Name = inputName
    ghenv.Component.Params.Input[input].Access = access
    
ghenv.Component.Attributes.Owner.OnPingDocument()

import Grasshopper.Kernel as gh
import rhinoscriptsyntax as rs
import Rhino
import scriptcontext as sc
from types import *
import random
import copy
import math

SGLibPanel = sc.sticky["SGLib_Panel"]
SGLibSkin = sc.sticky["SGLib_Skin"]
SGLibDesignFunction = sc.sticky["SGLib_DesignFunction"]

#GLOBAL PARAMETERS-------------------------------------------------------
INSTANCE_ID = str(ghenv.Component.InstanceGuid).rsplit("-",1)[1]
SKIN_NAME = INSTANCE_ID

DEFAULT_OFFSET_LEVEL = 0.0          #Offset distance of first panel at segments.Use list for different dimensions at each segment 
DEFAULT_OFFSET_PATH = 0.0           #Offset in elevation from path to be considered bottom of panel. Any value > 0 creates custom panel. 

DEFAULT_SKIN_WRAP = True            #Wrap at corners or create custom corner panels
SKIN_WRAP = True

RESET_BAY_AT_POINTS = True  #Start new bay at new segment

FLAT_MODE = False           #Low geometry mode
DRAW_MODE = "DEFAULT"       #"LADYBUG", "DEFAULT" 

DEFAULT_BAY_LIST = None     #default bays used in skin - 'None' will use all panel bays connected

SIZE_FROM_BAY_NUM = 0       # bay index to use to obtain grid size
FLOOR_HEIGHT = 0            #To set a floor height different than the panel height, otherwise
                            #uses height  of panel index provideded.

MIN_PANEL_WIDTH = .1        #if surface cell width is below this number it will be ignored and panel won't be created.
MIN_PANEL_HEIGHT = .1       #if surface cell height is below this number will be ignored and panel won't be created.
MIN_PANEL_AREA = .01        #if surface cell area is below this number will be ignored and panel won't be created.
PANEL_PROFILE_TOLERANCE = .0    #Maximum tolerance allowed to match current required panel properties with panel database.
RANDOM = random.Random()    #Global Random generator object

GENERATE_PANELS_ONLY = False
SURFACES_AS_PANELS = False
SURFACE_PANEL_MODIFIER =  "RESET"
RESET_DF_AFTER_SURFACE = False #Reset Design FUnctions between surfaces

#Internal global variables
warningData = []
PanelBay_List = []


#init set up global variables

sc.doc = Rhino.RhinoDoc.ActiveDoc
unitSystem = sc.doc.ModelUnitSystem
_UNIT_COEF = 1
if unitSystem == Rhino.UnitSystem.Feet: _UNIT_COEF = 3.28084
if unitSystem == Rhino.UnitSystem.Inches: _UNIT_COEF = 3.28084*12
if unitSystem == Rhino.UnitSystem.Millimeters: _UNIT_COEF = 1000
sc.doc = ghdoc



def CheckInputs():
    
    global warningData

    fatalError = False
    #-----skin parameters format check -----------------------------------------
    if skinParameters <> []:
        result = []
        for action in skinParameters: 
            if action : 
                try:
                    glVar = action.split("=", 1)
                    if len(glVar) <> 2: raise UserWarning
                    action = "global " + glVar[0] + "\n\r" + action
                    codeObj= compile(action,'<string>','exec')
                    eval(codeObj)
                except:
                    result.append(action)
        if result <> [] : warningData.append("Invalid skinParameters: " + str(result))
        
    #-----skin surfaces check -----------------------------------------        
    if _skinSurfaceList == [] or _skinSurfaceList == [None]: 
        warningData.append("Empty skinSurfaceList input - Unable to run")
        fatalError = True
    if not fatalError and SURFACES_AS_PANELS == True and (type(_skinSurfaceList[0]) <> Rhino.Geometry.Brep or _skinSurfaceList[0].Vertices.Count > 4) : 
        warningData.append("Invalid skinSurfaceList input - Unable to run")
        fatalError = True
        
    #-----design functions-----------------------------------------
    if designControllers <> []:
        for index, df in enumerate(designControllers):
            if df.__class__.__name__ not in ["LayoutDesignFunction", "PanelDesignFunction"]:
                warningData.append("Invalid Design Function #"+str(index+1)+": "+str(df))
                designControllers[index] = None
        try: 
            while True: designControllers.remove(None)
        except: pass
        
    #-----post processing parameters -----------------------------------------
    if postProcFunctions <> []:
        for index, ppf in enumerate(postProcFunctions):
            if ppf.__class__.__name__ not in ["PP_LadybugFunction"]:
                warningData.append("Invalid Post Processing Function #"+str(index+1)+": "+str(ppf))
                postProcFunctions[index] = None
        try: 
            while True: postProcFunctions.remove(None)
        except: pass
        
    #-----panel bay inputs -----------------------------------------                    
    global PanelBay_List
    numInputs = ghenv.Component.Params.Input.Count
    #Load panel bays from inputs to PanelBay_List
    for input in range(numInputs):
        item = ghenv.Component.Params.Input[input]
        if "panel_" in item.Name and item.VolatileDataCount > 0: 
            pList = []
            for i in range(item.VolatileDataCount) :
                isData =  item.VolatileData.get_DataItem(i)
                if isData:
                    panel = item.VolatileData.get_DataItem(i).Value
                    if not isinstance(panel, SGLibPanel): 
                        warningData.append("Invalid Panel #"+str(i)+" in " + item.Name+" - process stopped")
                        fatalError = True
                        break
                    pList.append(panel)
            if pList : PanelBay_List.append(pList)
            
    
    #Create a default panel if no panel or panel bay provided
    if PanelBay_List == []: 
        PanelBay_List.append([SGLibPanel()])
        msg = "-There are no valid Panel objects connected to the Skin Generator - default Panel Object created"
        warningData.append(msg)
        print ">"+msg
        
    #---Skin Parameters value check ----------------------------------------
    global DEFAULT_BAY_LIST
    if DEFAULT_BAY_LIST <> None:
        for bayNum in DEFAULT_BAY_LIST: 
            if bayNum not in range(1, len(PanelBay_List)+1):
                warningData.append("Invalid defaultBayList value "+str(DEFAULT_BAY_LIST)+" in Skin Paramaters - process stopped")
                fatalError = True; break
    
    return fatalError

#---------------------------------------------------------------------------------------------------------
#SKIN GENERATION SECTION
#---------------------------------------------------------------------------------------------------------


def SkinGenerator(myPanelBays, designControllers):

    #Create Skin matrix (grid with panel bay dimensions)
    SkinList = []  #Skin class instances (one per polysurface)
     
    # assign skin name to panel ansd reset panel controller 
    for panelBay in myPanelBays:
        for panel in panelBay: 
            panel.SetPanelProperty("SkinParentName", SKIN_NAME)
            #reset panel controllers and in FreeForm panels
            panelController = panel.GetPanelProperty("CustomGeoController") 
            if panelController <> None:
                panelController.Reset()
            #reset paneldynamic geometry instances    
            panelDynamicGeometry = panel.GetPanelProperty("CustomGeoOriginalBrep")
            if str(type(panelDynamicGeometry)) == "<type 'instance'>":
                 panelDynamicGeometry.Reset()
                 
    #reset values also in design controllers conected         
    for df in designControllers: 
        df.Reset() 
        
        
    #-----Skin Vertices Matrix creation data ----------------------------------- 
    numBay = 0
    if DEFAULT_BAY_LIST <> None: numBay = DEFAULT_BAY_LIST[0]-1
    
    dblFloorToFloor = myPanelBays[numBay][0].GetPanelProperty("PanelHeight") #get bay height from first panel
    dblBayWidth = 0
    for panel in myPanelBays[numBay]:
        dblBayWidth += panel.GetPanelProperty("PanelWidth")#get bay width from adding up its panel widths
        
    panelPtsMatrix = None #For Pre-defnied panel shapes is used when SURFACES_AS_PANELS is set to True
    #-----Skin generation data -----------------------------------------------------------------------------
    PanelTypes = {}
    BayData = {'BayCounter':[], 'PanelIndices':[], 'BayIndices':[]}
    BayData['BayCounter'] = myPanelBays + [0 for x in myPanelBays] #bay counters in format [list of bays, list of  counters]

    #Parameter/valuse list used to transfer data from Skin Generator component to Skin object 
    skinParams = [["OFFSET_LEVEL", DEFAULT_OFFSET_LEVEL], ["OFFSET_PATH", DEFAULT_OFFSET_PATH], ["SKIN_WRAP", DEFAULT_SKIN_WRAP],\
        ["RESET_BAY_AT_POINTS", RESET_BAY_AT_POINTS], ["FLAT_MODE", FLAT_MODE], ["DRAW_MODE", DRAW_MODE], ["BAY_LIST", DEFAULT_BAY_LIST],\
        ["MIN_PANEL_WIDTH", MIN_PANEL_WIDTH], ["MIN_PANEL_HEIGHT", MIN_PANEL_HEIGHT], ["MIN_PANEL_AREA", MIN_PANEL_AREA], ["PANEL_PROFILE_TOLERANCE",PANEL_PROFILE_TOLERANCE],\
        ["RANDOM_OBJECT", RANDOM],\
        ["DESIGN_FUNCTIONS", designControllers], ["GENERATE_PANELS_ONLY", GENERATE_PANELS_ONLY], ["FLOOR_HEIGHT", FLOOR_HEIGHT]]

    global warningData
    global _skinSurfaceList
    
    #Surface As Panels Mode - Skin Generation
    if  SURFACES_AS_PANELS == True:
        panelPtsMatrix = GetSurfaceCornerPts(_skinSurfaceList)
        if len(panelPtsMatrix[0]) == 0: warningData.append("Invalid Surface Panel objects")
        _skinSurfaceList = None
        #set Panels As Surface
        for panel in myPanelBays: panel[0].SetPanelProperty("SurfacePanelMode", True)
        tmpSkin = SGLibSkin(SKIN_NAME+"_"+str(0), None, panelPtsMatrix, myPanelBays, designControllers)
        #load default parameters
        for param in skinParams: tmpSkin.SetProperty(param[0], param[1])
        #generate panel blocks
        PanelTypes, BayData = tmpSkin.GeneratePanelBlocks(PanelTypes, BayData) 
        skinWarningData = tmpSkin.GetProperty("WARNING_DATA")
        if skinWarningData <> []:
            skinName = tmpSkin.GetProperty("SKIN_NAME")
            for warning in skinWarningData: ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, str("Skin "+skinName+" Internal Warning:\n\r" +warning))
            
    else:
        #Surface as Facade Mode - Skin Generation
        #Create Panel Matrix and Panel Blocks one surface object at a a time
        for index, objSkinSurface in enumerate(_skinSurfaceList):
            #create skin object
            if objSkinSurface == None : 
                warningData.append("Invalid Surface object #"+str(index+1)+": "+str(objSkinSurface)); continue
            tmpSkin = SGLibSkin(SKIN_NAME+"_"+str(index), objSkinSurface, None, myPanelBays, designControllers)
            # check if successful
            checkSurface = tmpSkin.GetProperty("SKIN_SURFACE_TYPE")
            if checkSurface <> "<type 'Brep'>" : 
                warningData.append("Invalid Surface object #"+str(index+1)+": "+str(objSkinSurface)); continue
            #load default parameters
            for param in skinParams: tmpSkin.SetProperty(param[0], param[1])
            #load parameters from surface object (specified in name)
            tmpSkin.LoadSurfaceProperties()
            #generate panel vertex matrix
            tmpSkin.GeneratePanelMatrix(dblBayWidth, dblFloorToFloor)
            #generate panel blocks
            PanelTypes, BayData = tmpSkin.GeneratePanelBlocks(PanelTypes, BayData) 
            
            SkinList.append(tmpSkin)
            skinWarningData = tmpSkin.GetProperty("WARNING_DATA")
            if skinWarningData <> []:
                skinName = tmpSkin.GetProperty("SKIN_NAME")
                for warning in skinWarningData: ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, str("Skin "+skinName+" Internal Warning:\n\r" +warning))    
            if RESET_DF_AFTER_SURFACE:        
                for df in designControllers: df.Reset() #reset values in design functions
                

    return PanelTypes, BayData


#----------------------------------------------------------------------------------------
#Create corner points matrix from surfaces in SURFACES_AS_PANELS Mode 
#----------------------------------------------------------------------------------------
def GetSurfaceCornerPts(surfaces):
    
    # set panel orientation based on SurfacePanel optional parameters , 
    # by altering order of vertices
    def SetSurfaceOrientation(cellPts):
        if len(cellPts)==4: 
            p1,p2,p3,p4 = cellPts
            if SURFACE_PANEL_MODIFIER ==  "RESET": cellPts = [p1,p2,p3,p4]           
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_90": cellPts = [p3,p1,p4,p2]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_90_FLIP": cellPts = [p1,p3,p2,p4]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_180": cellPts = [p4,p3,p2,p1]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_180_FLIP": cellPts = [p3,p4,p1,p2]           
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_270": cellPts = [p2,p4,p1,p3]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_270_FLIP": cellPts = [p4,p2,p3,p1]
            elif SURFACE_PANEL_MODIFIER ==  "FLIP": cellPts = [p2,p1,p4,p3] 
        elif len(cellPts) == 3:
            p1,p2,p3 = cellPts
            if SURFACE_PANEL_MODIFIER ==  "RESET": cellPts = [p1,p2,p3]           
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_90": cellPts = [p3,p1,p2]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_90_FLIP": cellPts = [p1,p3,p2]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_180": cellPts = [p3,p2,p1]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_180_FLIP": cellPts = [p3,p1,p2]           
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_270": cellPts = [p2,p1,p3]
            elif SURFACE_PANEL_MODIFIER ==  "ROTATE_270_FLIP": cellPts = [p2,p3,p1]
            elif SURFACE_PANEL_MODIFIER ==  "FLIP": cellPts = [p2,p1,p3]
            
        return cellPts
    
    #Process point data lists
    panelSides = 0
    ptsMatrix = [[]]; sidesMatrix = [[]]; normalsMatrix = [[]]; lengthsMatrix = [[]]; r = 0
    flatCellData = {'flatPts':[], 'flatPtLoc':[], 'ptKeys':[], 'normalKeys':[]}
    for i, surf in enumerate(surfaces):
        panelSides = surf.Vertices.Count
        
        if panelSides==4: #is a rectangular face,
            p1,p2,p4,p3 = [bp.Location for bp in surf.Vertices]
            pts = [p1,p2,p3,p4]
            #modify point order based on surface orientation parameter
            pts = SetSurfaceOrientation(pts)
            surfNormals = [Rhino.Geometry.Plane(nPts[0],nPts[1],nPts[2]).Normal for nPts in [[p1, p2, p3],[p2,p4,p3]]]
            surfLengths = [sum(rs.Distance(nPts[1], [nPts[0],nPts[2]])) for nPts in [[p1, p2, p3],[p2,p3,p4]]]
            flatCellData['flatPts'] += copy.deepcopy([p1,p2,p3,p4])
        elif panelSides == 3: #if triangular face
            p1,p2,p3 = [bp.Location for bp in surf.Vertices]
            p1,p2,p3 = SetSurfaceOrientation([p1,p2,p3])
            surfNormals = [Rhino.Geometry.Plane(p1,p2,p3).Normal]
            surfLengths = rs.Distance(p2, [p1,p3])
            flatCellData['flatPts'] += copy.deepcopy([p1,p2,p3])

            #add fourth point for compatibility(AT 0.1 unit from p1)
            p4 = Rhino.Geometry.Point3d(p1)  #repeat first point
            vecShift = Rhino.Geometry.Vector3d(p3-p2)
            vecShift = vecShift/vecShift.Length*sc.doc.ModelAbsoluteTolerance*3
            p4 += vecShift #move it a bit to avoid coincident pts
            pts = [p1,p2,p4,p3]
        else: continue #ignore surfaces with more than four points
        
        #detect end of surface row to build matrix
        if len(ptsMatrix[r])>0:
            ptsXYZ = [[pt.X, pt.Y, pt.Z] for pt in pts]
            prevPts = ptsMatrix[r][-1]
            prevPtsXYZ = [[pt.X, pt.Y, pt.Z] for pt in prevPts]
            matchPrevPoints = [xyz in prevPtsXYZ for xyz in ptsXYZ].count(True)
            firstPts = ptsMatrix[r][0]
            firstPtsXYZ = [[pt.X, pt.Y, pt.Z] for pt in firstPts]
            matchFirstPrevPoints = 0
            if len(ptsMatrix[r])>2:
                matchFirstPrevPoints = [xyz in firstPtsXYZ for xyz in prevPtsXYZ].count(True)            
            if matchPrevPoints == 0 or matchFirstPrevPoints > 1 :
                ptsMatrix.append([])
                sidesMatrix.append([])
                normalsMatrix.append([])
                lengthsMatrix.append([])
                r+=1
                
        ptsMatrix[r].append(pts)
        sidesMatrix[r].append(panelSides)
        normalsMatrix[r].append(surfNormals)
        lengthsMatrix[r].append(surfLengths)
        for index in range(panelSides):
            flatCellData['flatPtLoc'] += [[r, len(ptsMatrix[r])-1, index]]   
    
    #obtain surf corner points normals adding surrounding cells normal vectors
    
    ptKeys = []; normalKeys = []
    for pt in flatCellData['flatPts']:
        if pt in ptKeys: 
            continue
        indices = [i for i, x in enumerate(flatCellData['flatPts']) if x == pt]
        locs = [flatCellData['flatPtLoc'][index] for index in indices]
        acumNormal = Rhino.Geometry.Vector3d.Zero
        for row, col, id in locs:
            cellNormal = normalsMatrix[row][col][0]
            if len(normalsMatrix[row][col]) == 2:
                cellNormal += normalsMatrix[row][col][1]
            cellNormal.Unitize()
            cellNormal *= sum(lengthsMatrix[row][col])/len(lengthsMatrix[row][col])
            acumNormal += cellNormal
        ptKeys.append(pt)
        acumNormal /= len(locs)
        normalKeys.append(acumNormal)
        
    flatCellData['ptKeys'] = ptKeys
    flatCellData['normalKeys'] = normalKeys
    
    
    return [ptsMatrix, sidesMatrix, flatCellData]


    

#-----------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------
#Set Draw mode for panel bays(and their panels) provided
#----------------------------------------------------------------------------------------
def SetPanelsProperty(panelBayList, strPanelProperty, value):
    
    if strPanelProperty == "DrawMode":
        for panelBay in panelBayList:
            for panel  in panelBay :panel.SetDrawMode(value)
    else:
        for panelBay in panelBayList:
            for panel  in panelBay :panel.SetPanelProperty(strPanelProperty, value)

    
#---CLEAN UP SECTION--------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#Delete Panels and its block instances 
#----------------------------------------------------------------------------------------
def DeletePanelObjects(skinName):
    if not sc.sticky[skinName] : return
    for group in sc.sticky[skinName].values() :
        for item in group :
            if isinstance(item[0], SGLibPanel):
                item[0].DeleteBlockCopies() #Delete blocks first if blocks created   
                item[0].HideAll() #same as deleting all panel objects




#---RUN---------------------------------------------------------------------------------------------------

#init
sc.doc = Rhino.RhinoDoc.ActiveDoc
rs.EnableRedraw(False)


# -------Check inputs ----------------------------------------------------------------
fatalError = CheckInputs()


# Initialize skin variables to the sticky dict
if "Panel_Data"+INSTANCE_ID+SKIN_NAME not in sc.sticky: sc.sticky["Panel_Data"+INSTANCE_ID+SKIN_NAME] = []
if "count" not in sc.sticky : sc.sticky["count"] = 0

#-----Delete previous skin if present

if "Skin_Name"+INSTANCE_ID in sc.sticky : 
    oldSkinName = sc.sticky["Skin_Name"+INSTANCE_ID]
    DeletePanelObjects("Panel_Data"+INSTANCE_ID+oldSkinName)

sc.sticky["Skin_Name"+INSTANCE_ID] = SKIN_NAME

skinPanelData = []
skinBayData = []
sc.sticky["count"] += 1


# -------Execute Panel Skin Comamands  -----------------------------------------------
#PanelBay_List = [] 

# Reset values
if not _activate:
    sc.sticky["count"] = 0

    #Clean up Panels data
    sc.sticky["Panel_Data"+INSTANCE_ID+SKIN_NAME] = []
    
    
#  If activated , store paramters and run skin generator  

elif not fatalError and PanelBay_List <> []: 
    
    print "> Skin Designer Log: Generator "+SKIN_NAME
    
    SetPanelsProperty(PanelBay_List, "DrawMode", 'DEFAULT')
    SetPanelsProperty(PanelBay_List, "LB_ShadeThreshold", 0.1 * _UNIT_COEF)
    #Run Post Proc. functions if available
    for ppf in postProcFunctions:
        ppf.PP_SetPanelsProperties(PanelBay_List)

    #------Run Skin Generator-----------------------------------
    
    skinPanelData, skinBayData = SkinGenerator(PanelBay_List, designControllers)
    #Store in memory (for cleanup in next iteration)
    sc.sticky["Panel_Data"+INSTANCE_ID+SKIN_NAME] = skinPanelData

#-----Post Processing Run Section------------------------------------------------------------------

# init
postProcData = []
if "PostProc_Data" not in sc.sticky : sc.sticky["PostProc_Data"] = []

#Delete previous ladybug objects if created
#DeletePostProcObjects()
#sc.sticky["PostProc_Data"] = []
# ---- Post Processing functions-------------------------------------------------
if _activate and _skinSurfaceList != [] and PanelBay_List != []:
    if  postProcFunctions :       
        for ppFunc in postProcFunctions:
            postProcData.append(eval("ppFunc."+ppFunc.RunString()))
            
#-----Wrap up--------------------------------------------------------------------------
if warningData <> []: 
    for warning in warningData: ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, str(warning))
print sc.sticky["count"]
if skinPanelData : skinPanelData = skinPanelData.values()
if skinBayData :skinBayData = skinBayData.values()
rs.EnableRedraw(True)
sc.doc = ghdoc
